// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Lykke.Service.ChainalysisProxy.Client.AutorestClient
{
    using Lykke.Service.ChainalysisProxy.AutorestClient.Models;
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    public partial class ChainalysisRiskAPI : ServiceClient<ChainalysisRiskAPI>, IChainalysisRiskAPI
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        public System.Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        public JsonSerializerSettings SerializationSettings { get; private set; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        public JsonSerializerSettings DeserializationSettings { get; private set; }

        /// <summary>
        /// Initializes a new instance of the ChainalysisRiskAPI class.
        /// </summary>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public ChainalysisRiskAPI(params DelegatingHandler[] handlers) : base(handlers)
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the ChainalysisRiskAPI class.
        /// </summary>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public ChainalysisRiskAPI(HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : base(rootHandler, handlers)
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the ChainalysisRiskAPI class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public ChainalysisRiskAPI(System.Uri baseUri, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (baseUri == null)
            {
                throw new System.ArgumentNullException("baseUri");
            }
            BaseUri = baseUri;
        }

        /// <summary>
        /// Initializes a new instance of the ChainalysisRiskAPI class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public ChainalysisRiskAPI(System.Uri baseUri, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (baseUri == null)
            {
                throw new System.ArgumentNullException("baseUri");
            }
            BaseUri = baseUri;
        }

        /// <summary>
        /// An optional partial-method to perform custom initialization.
        ///</summary>
        partial void CustomInitialize();
        /// <summary>
        /// Initializes client properties.
        /// </summary>
        private void Initialize()
        {
            BaseUri = new System.Uri("http://localhost:5000/");
            SerializationSettings = new JsonSerializerSettings
            {
                Formatting = Newtonsoft.Json.Formatting.Indented,
                DateFormatHandling = Newtonsoft.Json.DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = Newtonsoft.Json.DateTimeZoneHandling.Utc,
                NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore,
                ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Serialize,
                ContractResolver = new ReadOnlyJsonContractResolver(),
                Converters = new  List<JsonConverter>
                    {
                        new Iso8601TimeSpanConverter()
                    }
            };
            DeserializationSettings = new JsonSerializerSettings
            {
                DateFormatHandling = Newtonsoft.Json.DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = Newtonsoft.Json.DateTimeZoneHandling.Utc,
                NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore,
                ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Serialize,
                ContractResolver = new ReadOnlyJsonContractResolver(),
                Converters = new List<JsonConverter>
                    {
                        new Iso8601TimeSpanConverter()
                    }
            };
            CustomInitialize();
        }
        /// <summary>
        /// List deposit addresses associated with a user.
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='limit'>
        /// The maximum number of items to return.
        /// </param>
        /// <param name='offset'>
        /// The offset into the result set
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IUserDepositAddressInfo>> UserByUserIdAddressesDepositGetWithHttpMessagesAsync(string userId, string token, int? limit = default(int?), int? offset = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("limit", limit);
                tracingParameters.Add("offset", offset);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdAddressesDepositGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/addresses/deposit").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            List<string> _queryParameters = new List<string>();
            if (limit != null)
            {
                _queryParameters.Add(string.Format("limit={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(limit, SerializationSettings).Trim('"'))));
            }
            if (offset != null)
            {
                _queryParameters.Add(string.Format("offset={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(offset, SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IUserDepositAddressInfo>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IUserDepositAddressInfo>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Add a deposit address associated with a user.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: The user is automatically created if it
        /// does not exist.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: The function is idempotent: If the
        /// deposit address is already associated with the user the function
        /// succeeds.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: If the deposit address is associated
        /// with a different user the function fails (see Response Messages
        /// below).&lt;/p&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='depositeAddress'>
        /// The deposit address
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<object>> UserByUserIdAddressesDepositPostWithHttpMessagesAsync(string userId, AddressImportModel depositeAddress, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (depositeAddress == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "depositeAddress");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("depositeAddress", depositeAddress);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdAddressesDepositPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/addresses/deposit").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(depositeAddress != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(depositeAddress, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 409)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<object>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IAddressInfo>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            // Deserialize Response
            if ((int)_statusCode == 409)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<string>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Delete a deposit address associated with a user.
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='address'>
        /// The address to delete
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<object>> UserByUserIdAddressesDepositByAddressDeleteWithHttpMessagesAsync(string userId, string address, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (address == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "address");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("address", address);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdAddressesDepositByAddressDelete", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/addresses/deposit/{address}").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            _url = _url.Replace("{address}", System.Uri.EscapeDataString(address));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<object>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<object>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Checks service is alive
        /// </summary>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<object>> IsAliveWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "IsAlive", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "api/IsAlive").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 500)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<object>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IsAliveResponse>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            // Deserialize Response
            if ((int)_statusCode == 500)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;List received outputs associated with a user.&lt;/p&gt;
        /// &lt;p&gt;For each output the following is listed:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;output&lt;/code&gt;: the actual output&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;status&lt;/code&gt;: the status of the output.Can be:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;unconfirmed&lt;/code&gt;: if the transaction has not yet
        /// confirmed&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;confirmed&lt;/code&gt;: if the transaction has confirmed, but
        /// not yet settled&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;settled&lt;/code&gt;: if the transaction has at least 5
        /// confirmations.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note:&lt;/strong&gt; Only settlet outputs take part in risk
        /// score calculations&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note:&lt;/strong&gt; Once an output has settled it cannot be
        /// deleted.&lt;/p&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='status'>
        /// The status of the output. Possible values include: 'unconfirmed',
        /// 'confirmed', 'settled', 'any'
        /// </param>
        /// <param name='limit'>
        /// The maximum number of items to return.
        /// </param>
        /// <param name='offset'>
        /// The offset into the result set
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IUserTransactionInfo>> UserByUserIdOutputsReceivedGetWithHttpMessagesAsync(string userId, string token, TransactionStatus? status = default(TransactionStatus?), int? limit = default(int?), int? offset = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("status", status);
                tracingParameters.Add("limit", limit);
                tracingParameters.Add("offset", offset);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdOutputsReceivedGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/outputs/received").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            List<string> _queryParameters = new List<string>();
            if (status != null)
            {
                _queryParameters.Add(string.Format("status={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(status, SerializationSettings).Trim('"'))));
            }
            if (limit != null)
            {
                _queryParameters.Add(string.Format("limit={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(limit, SerializationSettings).Trim('"'))));
            }
            if (offset != null)
            {
                _queryParameters.Add(string.Format("offset={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(offset, SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IUserTransactionInfo>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IUserTransactionInfo>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Add a received output associated with a user.&lt;/p&gt;
        /// &lt;p&gt;Call this function to register that your service has received a
        /// transaction output on behalf of a user.&lt;/p&gt;
        /// &lt;p&gt;A transaction output can be specified in two ways:&lt;/p&gt;
        /// &lt;ol&gt;
        /// &lt;li&gt;
        /// &lt;strong&gt;Transaction hash with output index.&lt;/strong&gt; E.g.the
        /// second output of the transaction with the
        /// hash&lt;code&gt;77b8b931b3f7cd17e06dee680b77b28bb0809c88087343d657600730ca7ba15e&lt;/code&gt;
        /// has index 1 and is specified like this
        /// &lt;code&gt;"77b8b931b3f7cd17e06dee680b77b28bb0809c88087343d657600730ca7ba15e:1"&lt;/code&gt;&lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;strong&gt;Transaction hash with output address.&lt;/strong&gt; E.g.the
        /// second output of the transaction with the
        /// hash&lt;code&gt;77b8b931b3f7cd17e06dee680b77b28bb0809c88087343d657600730ca7ba15e&lt;/code&gt;
        /// has output address
        /// &lt;code&gt;19eAxqvy3F3i2yNMWNjzwcKbSnMn9kpG1Z&lt;/code&gt; and is
        /// specified like this
        /// &lt;code&gt;"77b8b931b3f7cd17e06dee680b77b28bb0809c88087343d657600730ca7ba15e:19eAxqvy3F3i2yNMWNjzwcKbSnMn9kpG1Z"&lt;/code&gt;&lt;/li&gt;
        /// &lt;/ol&gt;
        /// &lt;p&gt;The first form is preferred because the second form is ambigious
        /// in cases where the transaction has more than one output to the specified
        /// address.&lt;/p&gt;
        /// &lt;p&gt;The return value contains a risk &lt;code&gt;score&lt;/code&gt;,
        /// e.g. &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;amber&lt;/code&gt;,
        /// or&lt;code&gt; green&lt;/code&gt;:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;red&lt;/code&gt;: This output was received directly from a
        /// suspicious sender.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;amber&lt;/code&gt;: This output was received from an
        /// unidentified sender.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;green&lt;/code&gt;: This output was received from an identified
        /// non-suspicious sender. &lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;p&gt;If the transaction has one or more confirmations and if the
        /// counterparty is identified the return value will contain&lt;code&gt;
        /// name&lt;/code&gt; and&lt;code&gt; category&lt;/code&gt; of the
        /// counterparty.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: If the transaction has not yet
        /// confirmed&lt;code&gt; score&lt;/code&gt; will be
        /// &lt;code&gt;amber&lt;/code&gt;.Therefore it is advised to call this
        /// function twice, once your service observes the output, and once the
        /// transaction has confirmed, just before crediting the amount of the output
        /// to the user.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: The user is automatically created if it
        /// does not exist.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: The function is idempotent: If the sent
        /// output is already associated with the user the function succeeds.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note:&lt;/strong&gt; If an output is not settled within 7
        /// days it is silently discarded.&lt;/p&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='output'>
        /// The transaction output
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IReceiveOutputInfo>> UserByUserIdOutputsReceivedPostWithHttpMessagesAsync(string userId, OutputImportModel output, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (output == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "output");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("output", output);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdOutputsReceivedPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/outputs/received").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(output != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(output, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IReceiveOutputInfo>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IReceiveOutputInfo>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Delete a received outputs associated with a user.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note:&lt;/strong&gt; Once an output has settled it cannot be
        /// deleted.&lt;/p&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='tx'>
        /// The hash of the transaction output
        /// </param>
        /// <param name='output'>
        /// The output index or output address
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<object>> UserByUserIdOutputsReceivedByTxByOutputDeleteWithHttpMessagesAsync(string userId, string tx, string output, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (tx == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "tx");
            }
            if (output == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "output");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("tx", tx);
                tracingParameters.Add("output", output);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdOutputsReceivedByTxByOutputDelete", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/outputs/received/{tx}/{output}").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            _url = _url.Replace("{tx}", System.Uri.EscapeDataString(tx));
            _url = _url.Replace("{output}", System.Uri.EscapeDataString(output));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<object>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<object>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;List sent outputs associated with a user.&lt;/p&gt;
        /// &lt;p&gt;For each output the following is listed:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;output&lt;/code&gt;: the actual output&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;status&lt;/code&gt;: the status of the output.Can be:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;unconfirmed&lt;/code&gt;: if the transaction has not yet
        /// confirmed&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;confirmed&lt;/code&gt;: if the transaction has confirmed, but
        /// not yet settled&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;settled&lt;/code&gt;: if the transaction has at least 5
        /// confirmations.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note:&lt;/strong&gt; Only settlet outputs take part in risk
        /// score calculations&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note:&lt;/strong&gt; Once an output has settled it cannot be
        /// deleted.&lt;/p&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='status'>
        /// The status of the output. Possible values include: 'unconfirmed',
        /// 'confirmed', 'settled', 'any'
        /// </param>
        /// <param name='limit'>
        /// The maximum number of items to return.
        /// </param>
        /// <param name='offset'>
        /// The offset into the result set
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IUserTransactionInfo>> UserByUserIdOutputsSentGetWithHttpMessagesAsync(string userId, string token, TransactionStatus? status = default(TransactionStatus?), int? limit = default(int?), int? offset = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("status", status);
                tracingParameters.Add("limit", limit);
                tracingParameters.Add("offset", offset);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdOutputsSentGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/outputs/sent").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            List<string> _queryParameters = new List<string>();
            if (status != null)
            {
                _queryParameters.Add(string.Format("status={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(status, SerializationSettings).Trim('"'))));
            }
            if (limit != null)
            {
                _queryParameters.Add(string.Format("limit={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(limit, SerializationSettings).Trim('"'))));
            }
            if (offset != null)
            {
                _queryParameters.Add(string.Format("offset={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(offset, SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IUserTransactionInfo>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IUserTransactionInfo>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Add a sent output associated with a user.&lt;/p&gt;
        /// &lt;p&gt;Call this function to register that your service has sent a
        /// transaction output on behalf of a user.&lt;/p&gt;
        /// &lt;p&gt;A transaction output can be specified in two ways:&lt;/p&gt;
        /// &lt;ol&gt;
        /// &lt;li&gt;
        /// &lt;strong&gt;Transaction hash with output index.&lt;/strong&gt; E.g.the
        /// second output of the transaction with the
        /// hash&lt;code&gt;77b8b931b3f7cd17e06dee680b77b28bb0809c88087343d657600730ca7ba15e&lt;/code&gt;
        /// has index 1 and is specified like this
        /// &lt;code&gt;"77b8b931b3f7cd17e06dee680b77b28bb0809c88087343d657600730ca7ba15e:1"&lt;/code&gt;&lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;strong&gt;Transaction hash with output address.&lt;/strong&gt; E.g.the
        /// second output of the transaction with the
        /// hash&lt;code&gt;77b8b931b3f7cd17e06dee680b77b28bb0809c88087343d657600730ca7ba15e&lt;/code&gt;
        /// has output address
        /// &lt;code&gt;19eAxqvy3F3i2yNMWNjzwcKbSnMn9kpG1Z&lt;/code&gt; and is
        /// specified like this
        /// &lt;code&gt;"77b8b931b3f7cd17e06dee680b77b28bb0809c88087343d657600730ca7ba15e:19eAxqvy3F3i2yNMWNjzwcKbSnMn9kpG1Z"&lt;/code&gt;&lt;/li&gt;
        /// &lt;/ol&gt;
        /// &lt;p&gt;The first form is preferred because the second form is ambigious
        /// in cases where the transaction has more than one output to the specified
        /// address.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: The user is automatically created if it
        /// does not exist.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: The function is idempotent: If the sent
        /// output is already associated with the user the function succeeds.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note:&lt;/strong&gt; If an output is not settled within 7
        /// days it is silently discarded.&lt;/p&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='output'>
        /// The transaction output
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<object>> UserByUserIdOutputsSentPostWithHttpMessagesAsync(string userId, OutputImportModel output, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (output == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "output");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("output", output);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdOutputsSentPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/outputs/sent").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(output != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(output, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<object>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<object>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Delete a sent outputs associated with a user.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note:&lt;/strong&gt; Once an output has settled it cannot be
        /// deleted.&lt;/p&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='tx'>
        /// The hash of the transaction output
        /// </param>
        /// <param name='output'>
        /// The output index or output address
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<object>> UserByUserIdOutputsSentByTxByOutputDeleteWithHttpMessagesAsync(string userId, string tx, string output, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (tx == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "tx");
            }
            if (output == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "output");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("tx", tx);
                tracingParameters.Add("output", output);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdOutputsSentByTxByOutputDelete", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/outputs/sent/{tx}/{output}").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            _url = _url.Replace("{tx}", System.Uri.EscapeDataString(tx));
            _url = _url.Replace("{output}", System.Uri.EscapeDataString(output));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<object>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<object>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;List users with optional filters.&lt;/p&gt;
        /// &lt;p&gt;For each user the following is returned:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;userId&lt;/code&gt;: the ID of the user&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;score&lt;/code&gt;: the risk score of the user.E.g.
        /// &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;amber&lt;/code&gt;,
        /// or&lt;code&gt; green&lt;/code&gt;. Only included if the user has sent or
        /// received value.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;scoreUpdatedDate&lt;/code&gt;: the last time the risk score has
        /// been updated in POSIX format. Only included if the user has sent or
        /// received value.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;lastActivity&lt;/code&gt;: the last time the user sent or
        /// received value in POSIX format. Only included if the user has sent or
        /// received value.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;p&gt;Hint: to only return users with score&lt;code&gt; red&lt;/code&gt;
        /// set the &lt;code&gt;score&lt;/code&gt; parameter to&lt;code&gt;
        /// red&lt;/code&gt;&lt;/p&gt;
        /// &lt;p&gt;Hint: To only return users that have sent or received value over
        /// the last 2 weeks set the&lt;code&gt; maxIdleDays&lt;/code&gt; parameter to
        /// 14&lt;/p&gt;
        /// </summary>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='maxIdleDays'>
        /// Optionally filter the users by specifying the maximum numbers of days
        /// without sent or received activity.
        /// </param>
        /// <param name='score'>
        /// Optionally filter the users by specifying the risk score. Possible values
        /// include: 'red', 'amber', 'green'
        /// </param>
        /// <param name='limit'>
        /// The maximum number of items to return.
        /// </param>
        /// <param name='offset'>
        /// The offset into the result set
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IUserInfo>> UserGetWithHttpMessagesAsync(string token, int? maxIdleDays = default(int?), Contracts.RiskScore? score = default(Contracts.RiskScore?), int? limit = default(int?), int? offset = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("maxIdleDays", maxIdleDays);
                tracingParameters.Add("score", score);
                tracingParameters.Add("limit", limit);
                tracingParameters.Add("offset", offset);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user").ToString();
            List<string> _queryParameters = new List<string>();
            if (maxIdleDays != null)
            {
                _queryParameters.Add(string.Format("maxIdleDays={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(maxIdleDays, SerializationSettings).Trim('"'))));
            }
            if (score != null)
            {
                _queryParameters.Add(string.Format("score={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(score, SerializationSettings).Trim('"'))));
            }
            if (limit != null)
            {
                _queryParameters.Add(string.Format("limit={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(limit, SerializationSettings).Trim('"'))));
            }
            if (offset != null)
            {
                _queryParameters.Add(string.Format("offset={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(offset, SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IUserInfo>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IUserInfo>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Import a user with sent and received history.&lt;/p&gt;
        /// &lt;p&gt;With this function you can import a whole user with sent and
        /// received output history and all deposit and withdrawal addresses.&lt;/p&gt;
        /// &lt;p&gt;The import format is as follows:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;userId&lt;/code&gt;: the unique ID of the user. The caller
        /// decides the user ID and can specify any value containing the folllowing
        /// characters '-' '_' 'a-z' 'A-Z' '0-9' with a maximum of 200
        /// characters.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;depositAddresses&lt;/code&gt;: The deposit addresses of the
        /// user. Specified as an array of strings where each address must be a valid
        /// Bitcoin addresses.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;withdrawalAddresses&lt;/code&gt;: The withdrawal addresses of
        /// the user. Specified as an array of strings where each address must be a
        /// valid Bitcoin addresses.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;sentOutputs&lt;/code&gt;: The transaction outputs sent by the
        /// user.See below for a specification on how to format an output.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;receivedOutputs&lt;/code&gt;: The transaction outputs received
        /// by the user.See below for a specification on how to format an
        /// output.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;p&gt;Sent or received outputs can be specified in two ways:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;A transaction hash followed by the index of the output counting
        /// from zero: &lt;code&gt;tx-hash:output-index&lt;/code&gt;.Exmaple: The first
        /// output of of the transaction&lt;code&gt;
        /// d03104f31dfbea2fa0e9c871790fbd1864d5b43354612c5b0b725eeb73bb7b8e&lt;/code&gt;
        /// is specified like this
        /// &lt;code&gt;"d03104f31dfbea2fa0e9c871790fbd1864d5b43354612c5b0b725eeb73bb7b8e:0"&lt;/code&gt;
        /// and the second output like this
        /// &lt;code&gt;"d03104f31dfbea2fa0e9c871790fbd1864d5b43354612c5b0b725eeb73bb7b8e:1"&lt;/code&gt;&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;A transaction hash followed by the address of the output:
        /// &lt;code&gt;tx-hash:output-address&lt;/code&gt;.Exmaple: The first output
        /// of of the transaction&lt;code&gt;
        /// d03104f31dfbea2fa0e9c871790fbd1864d5b43354612c5b0b725eeb73bb7b8e&lt;/code&gt;
        /// is specified like this
        /// &lt;code&gt;"d03104f31dfbea2fa0e9c871790fbd1864d5b43354612c5b0b725eeb73bb7b8e:1ERWgzFdPwbAYM6GWg9dUX1Q3KssatXgYz"&lt;/code&gt;
        /// and the second output like this
        /// &lt;code&gt;"d03104f31dfbea2fa0e9c871790fbd1864d5b43354612c5b0b725eeb73bb7b8e:16F5EJE8mgiEDJzKqRdWUzdB54WceDRfjx"&lt;/code&gt;&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: The second output format can be
        /// ambigious in cases where the output address appears more than once in the
        /// outputs of a single transaction. If this occurs the first matching output
        /// is selected.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: Importing a user with sent or received
        /// outputs with less than 5 confirmations will fail.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: Subsequent import calls with the same
        /// userId are incremental, meaning that you can import another (E.g. new)
        /// version of a user on top of what is registered for that user already.In
        /// other words, any existing outputs or addresses which are not in the new
        /// import will NOT get deleted.&lt;/p&gt;
        /// &lt;p&gt;
        /// &lt;strong&gt;Note&lt;/strong&gt;: If one of the deposit addresses are
        /// associated with a different user the function fails(see Response Messages
        /// below).&lt;/p&gt;
        /// </summary>
        /// <param name='userImport'>
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<string>> UserImportPostWithHttpMessagesAsync(UserImportModel userImport, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userImport == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userImport");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userImport", userImport);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserImportPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/import").ToString();
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(userImport != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(userImport, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 409)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<string>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 409)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<string>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Get information about a user.&lt;/p&gt;
        /// &lt;p&gt;The follwing information is returned:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;userId&lt;/code&gt;: the ID of the user&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;creationDate&lt;/code&gt;: the POSIX time when the user was
        /// created&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;comment&lt;/code&gt;: an arbitrary string that can be set using
        /// another API function.Only included if set.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;score&lt;/code&gt;: the risk score of the user. E.g.
        /// &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;amber&lt;/code&gt;,
        /// or&lt;code&gt; green&lt;/code&gt;. Only included if the user has sent or
        /// received value.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;scoreUpdatedDate&lt;/code&gt;: the last time the risk score has
        /// been updated in POSIX format. Only included if the user has sent or
        /// received value.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;lastActivity&lt;/code&gt;: the last time the user sent or
        /// received value in POSIX format. Only included if the user has sent or
        /// received value.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;exposureDetails&lt;/code&gt;: detailed exposure data.Only
        /// included if the user has sent or received value.&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;category&lt;/code&gt;: exposure category.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;sentIndirectExposure&lt;/code&gt;: funds sent
        /// indirectly.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;sentDirectExposure&lt;/code&gt;: funds sent directly.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;receivedIndirectExposure&lt;/code&gt;: funds received
        /// indirectly.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;
        /// &lt;code&gt;receivedDirectExposure&lt;/code&gt;: funds received
        /// directly.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IUserDetails>> UserByUserIdGetWithHttpMessagesAsync(string userId, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IUserDetails>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IUserDetails>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Set the &lt;code&gt;comment&lt;/code&gt; string on a
        /// user.&lt;/p&gt;
        /// &lt;p&gt;This is a convenience function that allows you to set an arbitrary
        /// string for a user.When retrieving a user the string is returned.&lt;/p&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='comment'>
        /// The deposit address
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<object>> UserByUserIdCommentPostWithHttpMessagesAsync(string userId, CommentModel comment, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (comment == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "comment");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("comment", comment);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdCommentPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/comment").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(comment != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(comment, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<object>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<object>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;List withdrawal addresses associated with a user.&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;Each withdrawal address is given a risk&lt;code&gt;
        /// score&lt;/code&gt;. E.g. &lt;code&gt;red&lt;/code&gt;,
        /// &lt;code&gt;amber&lt;/code&gt;, or&lt;code&gt;
        /// green&lt;/code&gt;.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;If a withdrawal address belongs to a known service,
        /// then&lt;code&gt; name&lt;/code&gt; and&lt;code&gt; category&lt;/code&gt;
        /// will be included and gives the name and category of that service.
        /// Otherwise&lt;code&gt; name&lt;/code&gt; and&lt;code&gt;
        /// category&lt;/code&gt; will be omitted.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='limit'>
        /// The maximum number of items to return.
        /// </param>
        /// <param name='offset'>
        /// The offset into the result set
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IUserWithdrawAddressInfo>> UserByUserIdAddressesWithdrawalGetWithHttpMessagesAsync(string userId, string token, int? limit = default(int?), int? offset = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("limit", limit);
                tracingParameters.Add("offset", offset);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdAddressesWithdrawalGet", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/addresses/withdrawal").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            List<string> _queryParameters = new List<string>();
            if (limit != null)
            {
                _queryParameters.Add(string.Format("limit={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(limit, SerializationSettings).Trim('"'))));
            }
            if (offset != null)
            {
                _queryParameters.Add(string.Format("offset={0}", System.Uri.EscapeDataString(SafeJsonConvert.SerializeObject(offset, SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IUserWithdrawAddressInfo>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IUserWithdrawAddressInfo>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Add a withdrawal address associated with a user.&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;The user is automatically created if it does not exist.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;The function is idempotent: If the withdrawal address is already
        /// associated with the user the function succeeds.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;p&gt;The function returns an analysis of the withdrawal
        /// address:&lt;/p&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;A risk &lt;code&gt;score&lt;/code&gt;.E.g.
        /// &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;amber&lt;/code&gt;,
        /// or&lt;code&gt; green&lt;/code&gt;.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;
        /// &lt;p&gt;If a withdrawal address belongs to a known service,
        /// then&lt;code&gt; name&lt;/code&gt; and&lt;code&gt; category&lt;/code&gt;
        /// will be included and gives the name and category of that service.
        /// Otherwise&lt;code&gt; name&lt;/code&gt; and&lt;code&gt;
        /// category&lt;/code&gt; will be omitted.&lt;/p&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;p&gt;Hint: This function could be called both when a user pastes in the
        /// withdrawal address for the first time, and also before each subsequent
        /// withdrawal.&lt;/p&gt;
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='withdrawalAddress'>
        /// The withdrawal address
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<IWithdrawAddressInfo>> UserByUserIdAddressesWithdrawalPostWithHttpMessagesAsync(string userId, AddressImportModel withdrawalAddress, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (withdrawalAddress == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "withdrawalAddress");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("withdrawalAddress", withdrawalAddress);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdAddressesWithdrawalPost", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/addresses/withdrawal").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(withdrawalAddress != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(withdrawalAddress, SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<IWithdrawAddressInfo>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<IWithdrawAddressInfo>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Delete a withdrawal address associated with a user.
        /// </summary>
        /// <param name='userId'>
        /// The ID of the user
        /// </param>
        /// <param name='address'>
        /// The address to delete
        /// </param>
        /// <param name='token'>
        /// API-key
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<object>> UserByUserIdAddressesWithdrawalByAddressDeleteWithHttpMessagesAsync(string userId, string address, string token, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (userId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "userId");
            }
            if (address == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "address");
            }
            if (token == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "token");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("userId", userId);
                tracingParameters.Add("address", address);
                tracingParameters.Add("token", token);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "UserByUserIdAddressesWithdrawalByAddressDelete", tracingParameters);
            }
            // Construct URL
            var _baseUrl = BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "user/{userId}/addresses/withdrawal/{address}").ToString();
            _url = _url.Replace("{userId}", System.Uri.EscapeDataString(userId));
            _url = _url.Replace("{address}", System.Uri.EscapeDataString(address));
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (token != null)
            {
                if (_httpRequest.Headers.Contains("Token"))
                {
                    _httpRequest.Headers.Remove("Token");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Token", token);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<object>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = SafeJsonConvert.DeserializeObject<object>(_responseContent, DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
